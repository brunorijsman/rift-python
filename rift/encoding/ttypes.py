#
#
# $Id
#
# Copyright (c) 2021, Juniper Networks, Inc.
# All rights reserved.
#
#
#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import common.ttypes

from thrift.transport import TTransport


class PacketHeader(object):
    """
    Common RIFT packet header.

    Attributes:
     - major_version: Major version of protocol.
     - minor_version: Minor version of protocol.
     - sender: Node sending the packet, in case of LIE/TIRE/TIDE
    also the originator of it.
     - level: Level of the node sending the packet, required on everything
    except LIEs. Lack of presence on LIEs indicates UNDEFINED_LEVEL
    and is used in ZTP procedures.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'major_version', None, 7, ),  # 1
        (2, TType.I16, 'minor_version', None, 0, ),  # 2
        (3, TType.I64, 'sender', None, None, ),  # 3
        (4, TType.BYTE, 'level', None, None, ),  # 4
    )

    def __init__(self, major_version=thrift_spec[1][4], minor_version=thrift_spec[2][4], sender=None, level=None,):
        if major_version is self.thrift_spec[1][4]:
            major_version = 7
        self.major_version = major_version
        if minor_version is self.thrift_spec[2][4]:
            minor_version = 0
        self.minor_version = minor_version
        self.sender = sender
        self.level = level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.major_version = None
        self.minor_version = None
        self.sender = None
        self.level = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.major_version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.minor_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sender = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PacketHeader')
        if self.major_version is not None:
            oprot.writeFieldBegin('major_version', TType.BYTE, 1)
            oprot.writeByte(self.major_version)
            oprot.writeFieldEnd()
        if self.minor_version is not None:
            oprot.writeFieldBegin('minor_version', TType.I16, 2)
            oprot.writeI16(self.minor_version)
            oprot.writeFieldEnd()
        if self.sender is not None:
            oprot.writeFieldBegin('sender', TType.I64, 3)
            oprot.writeI64(self.sender)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 4)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.major_version is None:
            raise TProtocolException(message='Required field major_version is unset!')
        if self.minor_version is None:
            raise TProtocolException(message='Required field minor_version is unset!')
        if self.sender is None:
            raise TProtocolException(message='Required field sender is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Community(object):
    """
    Prefix community.

    Attributes:
     - top: Higher order bits
     - bottom: Lower order bits
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'top', None, None, ),  # 1
        (2, TType.I32, 'bottom', None, None, ),  # 2
    )

    def __init__(self, top=None, bottom=None,):
        super(Community, self).__setattr__('top', top)
        super(Community, self).__setattr__('bottom', bottom)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.top, self.bottom, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_top= None
        __var_bottom= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    __var_top = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    __var_bottom = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            top=__var_top,
            bottom=__var_bottom,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Community')
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.I32, 1)
            oprot.writeI32(self.top)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.I32, 2)
            oprot.writeI32(self.bottom)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.top is None:
            raise TProtocolException(message='Required field top is unset!')
        if self.bottom is None:
            raise TProtocolException(message='Required field bottom is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Neighbor(object):
    """
    Neighbor structure.

    Attributes:
     - originator: System ID of the originator.
     - remote_id: ID of remote side of the link.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'originator', None, None, ),  # 1
        (2, TType.I32, 'remote_id', None, None, ),  # 2
    )

    def __init__(self, originator=None, remote_id=None,):
        super(Neighbor, self).__setattr__('originator', originator)
        super(Neighbor, self).__setattr__('remote_id', remote_id)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.originator, self.remote_id, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_originator= None
        __var_remote_id= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    __var_originator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    __var_remote_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            originator=__var_originator,
            remote_id=__var_remote_id,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Neighbor')
        if self.originator is not None:
            oprot.writeFieldBegin('originator', TType.I64, 1)
            oprot.writeI64(self.originator)
            oprot.writeFieldEnd()
        if self.remote_id is not None:
            oprot.writeFieldBegin('remote_id', TType.I32, 2)
            oprot.writeI32(self.remote_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.originator is None:
            raise TProtocolException(message='Required field originator is unset!')
        if self.remote_id is None:
            raise TProtocolException(message='Required field remote_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeCapabilities(object):
    """
    Capabilities the node supports.

    Attributes:
     - protocol_minor_version: Must advertise supported minor version dialect that way.
     - flood_reduction: indicates that node supports flood reduction.
     - hierarchy_indications: indicates place in hierarchy, i.e. top-of-fabric or
    leaf only (in ZTP) or support for leaf-2-leaf
    procedures.
     - auto_evpn_support: <auto-evpn>
    indicates whether auto-evpn feature is implemented on this node (but not necessarily enabled).
     - auto_flood_reflection_support: <auto-flood-reflection>
    indicates whether auto-flood-reflection feature is implemented on this node (but not necessarily enabled).
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I16, 'protocol_minor_version', None, 0, ),  # 1
        (2, TType.BOOL, 'flood_reduction', None, True, ),  # 2
        (3, TType.I32, 'hierarchy_indications', None, None, ),  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.BOOL, 'auto_evpn_support', None, False, ),  # 10
        None,  # 11
        None,  # 12
        None,  # 13
        None,  # 14
        None,  # 15
        None,  # 16
        None,  # 17
        None,  # 18
        None,  # 19
        (20, TType.BOOL, 'auto_flood_reflection_support', None, False, ),  # 20
    )

    def __init__(self, protocol_minor_version=thrift_spec[1][4], flood_reduction=thrift_spec[2][4], hierarchy_indications=None, auto_evpn_support=thrift_spec[10][4], auto_flood_reflection_support=thrift_spec[20][4],):
        if protocol_minor_version is self.thrift_spec[1][4]:
            protocol_minor_version = 0
        super(NodeCapabilities, self).__setattr__('protocol_minor_version', protocol_minor_version)
        super(NodeCapabilities, self).__setattr__('flood_reduction', flood_reduction)
        super(NodeCapabilities, self).__setattr__('hierarchy_indications', hierarchy_indications)
        super(NodeCapabilities, self).__setattr__('auto_evpn_support', auto_evpn_support)
        super(NodeCapabilities, self).__setattr__('auto_flood_reflection_support', auto_flood_reflection_support)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.protocol_minor_version, self.flood_reduction, self.hierarchy_indications, self.auto_evpn_support, self.auto_flood_reflection_support, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_protocol_minor_version= None
        __var_flood_reduction= None
        __var_hierarchy_indications= None
        __var_auto_evpn_support= None
        __var_auto_flood_reflection_support= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    __var_protocol_minor_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    __var_flood_reduction = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    __var_hierarchy_indications = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    __var_auto_evpn_support = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    __var_auto_flood_reflection_support = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            protocol_minor_version=__var_protocol_minor_version,
            flood_reduction=__var_flood_reduction,
            hierarchy_indications=__var_hierarchy_indications,
            auto_evpn_support=__var_auto_evpn_support,
            auto_flood_reflection_support=__var_auto_flood_reflection_support,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeCapabilities')
        if self.protocol_minor_version is not None:
            oprot.writeFieldBegin('protocol_minor_version', TType.I16, 1)
            oprot.writeI16(self.protocol_minor_version)
            oprot.writeFieldEnd()
        if self.flood_reduction is not None:
            oprot.writeFieldBegin('flood_reduction', TType.BOOL, 2)
            oprot.writeBool(self.flood_reduction)
            oprot.writeFieldEnd()
        if self.hierarchy_indications is not None:
            oprot.writeFieldBegin('hierarchy_indications', TType.I32, 3)
            oprot.writeI32(self.hierarchy_indications)
            oprot.writeFieldEnd()
        if self.auto_evpn_support is not None:
            oprot.writeFieldBegin('auto_evpn_support', TType.BOOL, 10)
            oprot.writeBool(self.auto_evpn_support)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_support is not None:
            oprot.writeFieldBegin('auto_flood_reflection_support', TType.BOOL, 20)
            oprot.writeBool(self.auto_flood_reflection_support)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_minor_version is None:
            raise TProtocolException(message='Required field protocol_minor_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LinkCapabilities(object):
    """
    Link capabilities.

    Attributes:
     - bfd: Indicates that the link is supporting BFD.
     - ipv4_forwarding_capable: Indicates whether the interface will support IPv4 forwarding.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'bfd', None, True, ),  # 1
        (2, TType.BOOL, 'ipv4_forwarding_capable', None, True, ),  # 2
    )

    def __init__(self, bfd=thrift_spec[1][4], ipv4_forwarding_capable=thrift_spec[2][4],):
        super(LinkCapabilities, self).__setattr__('bfd', bfd)
        super(LinkCapabilities, self).__setattr__('ipv4_forwarding_capable', ipv4_forwarding_capable)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.bfd, self.ipv4_forwarding_capable, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_bfd= None
        __var_ipv4_forwarding_capable= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    __var_bfd = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    __var_ipv4_forwarding_capable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            bfd=__var_bfd,
            ipv4_forwarding_capable=__var_ipv4_forwarding_capable,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LinkCapabilities')
        if self.bfd is not None:
            oprot.writeFieldBegin('bfd', TType.BOOL, 1)
            oprot.writeBool(self.bfd)
            oprot.writeFieldEnd()
        if self.ipv4_forwarding_capable is not None:
            oprot.writeFieldBegin('ipv4_forwarding_capable', TType.BOOL, 2)
            oprot.writeBool(self.ipv4_forwarding_capable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LIEPacket(object):
    """
    RIFT LIE Packet.

    @note: this node's level is already included on the packet header

    Attributes:
     - name: Node or adjacency name.
     - local_id: Local link ID.
     - flood_port: UDP port to which we can receive flooded TIEs.
     - link_mtu_size: Layer 3 MTU, used to discover mismatch.
     - link_bandwidth: Local link bandwidth on the interface.
     - neighbor: Reflects the neighbor once received to provide
    3-way connectivity.
     - pod: Node's PoD.
     - node_capabilities: Node capabilities supported.
     - link_capabilities: Capabilities of this link.
     - holdtime: Required holdtime of the adjacency, i.e. for how
    long a period should adjacency be kept up without valid LIE reception.
     - label: Optional, unsolicited, downstream assigned locally significant label
    value for the adjacency.
     - not_a_ztp_offer: Indicates that the level on the LIE must not be used
    to derive a ZTP level by the receiving node.
     - you_are_flood_repeater: Indicates to northbound neighbor that it should
    be reflooding TIEs received from this node to achieve flood
    reduction and balancing for northbound flooding.
     - you_are_sending_too_quickly: Indicates to neighbor to flood node TIEs only and slow down
    all other TIEs. Ignored when received from southbound neighbor.
     - instance_name: Instance name in case multiple RIFT instances running on same
    interface.
     - fabric_id: <auto-evpn>
    provides the optional ID of the configured auto-evpn fabric.
     - auto_evpn_version: provides optional version of EVPN ZTP as 256 * MAJOR + MINOR
     - auto_flood_reflection_version: It provides optional version of FR ZTP as 256 * MAJOR + MINOR, indicates support for auto FR
     - auto_flood_reflection_cluster_id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
        (2, TType.I32, 'local_id', None, None, ),  # 2
        (3, TType.I16, 'flood_port', None, 915, ),  # 3
        (4, TType.I32, 'link_mtu_size', None, 1400, ),  # 4
        (5, TType.I32, 'link_bandwidth', None, 100, ),  # 5
        (6, TType.STRUCT, 'neighbor', (Neighbor, Neighbor.thrift_spec), None, ),  # 6
        (7, TType.I32, 'pod', None, 0, ),  # 7
        None,  # 8
        None,  # 9
        (10, TType.STRUCT, 'node_capabilities', (NodeCapabilities, NodeCapabilities.thrift_spec), None, ),  # 10
        (11, TType.STRUCT, 'link_capabilities', (LinkCapabilities, LinkCapabilities.thrift_spec), None, ),  # 11
        (12, TType.I16, 'holdtime', None, 3, ),  # 12
        (13, TType.I32, 'label', None, None, ),  # 13
        None,  # 14
        None,  # 15
        None,  # 16
        None,  # 17
        None,  # 18
        None,  # 19
        None,  # 20
        (21, TType.BOOL, 'not_a_ztp_offer', None, False, ),  # 21
        (22, TType.BOOL, 'you_are_flood_repeater', None, True, ),  # 22
        (23, TType.BOOL, 'you_are_sending_too_quickly', None, False, ),  # 23
        (24, TType.STRING, 'instance_name', 'UTF8', None, ),  # 24
        None,  # 25
        None,  # 26
        None,  # 27
        None,  # 28
        None,  # 29
        None,  # 30
        None,  # 31
        None,  # 32
        None,  # 33
        None,  # 34
        (35, TType.I16, 'fabric_id', None, None, ),  # 35
        (36, TType.I16, 'auto_evpn_version', None, None, ),  # 36
        None,  # 37
        None,  # 38
        None,  # 39
        (40, TType.I16, 'auto_flood_reflection_version', None, None, ),  # 40
        (41, TType.I32, 'auto_flood_reflection_cluster_id', None, None, ),  # 41
    )

    def __init__(self, name=None, local_id=None, flood_port=thrift_spec[3][4], link_mtu_size=thrift_spec[4][4], link_bandwidth=thrift_spec[5][4], neighbor=None, pod=thrift_spec[7][4], node_capabilities=None, link_capabilities=None, holdtime=thrift_spec[12][4], label=None, not_a_ztp_offer=thrift_spec[21][4], you_are_flood_repeater=thrift_spec[22][4], you_are_sending_too_quickly=thrift_spec[23][4], instance_name=None, fabric_id=None, auto_evpn_version=None, auto_flood_reflection_version=None, auto_flood_reflection_cluster_id=None,):
        self.name = name
        self.local_id = local_id
        if flood_port is self.thrift_spec[3][4]:
            flood_port = 915
        self.flood_port = flood_port
        if link_mtu_size is self.thrift_spec[4][4]:
            link_mtu_size = 1400
        self.link_mtu_size = link_mtu_size
        if link_bandwidth is self.thrift_spec[5][4]:
            link_bandwidth = 100
        self.link_bandwidth = link_bandwidth
        self.neighbor = neighbor
        if pod is self.thrift_spec[7][4]:
            pod = 0
        self.pod = pod
        self.node_capabilities = node_capabilities
        self.link_capabilities = link_capabilities
        if holdtime is self.thrift_spec[12][4]:
            holdtime = 3
        self.holdtime = holdtime
        self.label = label
        self.not_a_ztp_offer = not_a_ztp_offer
        self.you_are_flood_repeater = you_are_flood_repeater
        self.you_are_sending_too_quickly = you_are_sending_too_quickly
        self.instance_name = instance_name
        self.fabric_id = fabric_id
        self.auto_evpn_version = auto_evpn_version
        self.auto_flood_reflection_version = auto_flood_reflection_version
        self.auto_flood_reflection_cluster_id = auto_flood_reflection_cluster_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.name = None
        self.local_id = None
        self.flood_port = None
        self.link_mtu_size = None
        self.link_bandwidth = None
        self.neighbor = None
        self.pod = None
        self.node_capabilities = None
        self.link_capabilities = None
        self.holdtime = None
        self.label = None
        self.not_a_ztp_offer = None
        self.you_are_flood_repeater = None
        self.you_are_sending_too_quickly = None
        self.instance_name = None
        self.fabric_id = None
        self.auto_evpn_version = None
        self.auto_flood_reflection_version = None
        self.auto_flood_reflection_cluster_id = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.local_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.flood_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.link_mtu_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.link_bandwidth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.neighbor = Neighbor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.pod = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.node_capabilities = NodeCapabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.link_capabilities = LinkCapabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I16:
                    self.holdtime = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.label = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.BOOL:
                    self.not_a_ztp_offer = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.you_are_flood_repeater = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.BOOL:
                    self.you_are_sending_too_quickly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRING:
                    self.instance_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.I16:
                    self.fabric_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.I16:
                    self.auto_evpn_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 40:
                if ftype == TType.I16:
                    self.auto_flood_reflection_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 41:
                if ftype == TType.I32:
                    self.auto_flood_reflection_cluster_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LIEPacket')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.local_id is not None:
            oprot.writeFieldBegin('local_id', TType.I32, 2)
            oprot.writeI32(self.local_id)
            oprot.writeFieldEnd()
        if self.flood_port is not None:
            oprot.writeFieldBegin('flood_port', TType.I16, 3)
            oprot.writeI16(self.flood_port)
            oprot.writeFieldEnd()
        if self.link_mtu_size is not None:
            oprot.writeFieldBegin('link_mtu_size', TType.I32, 4)
            oprot.writeI32(self.link_mtu_size)
            oprot.writeFieldEnd()
        if self.link_bandwidth is not None:
            oprot.writeFieldBegin('link_bandwidth', TType.I32, 5)
            oprot.writeI32(self.link_bandwidth)
            oprot.writeFieldEnd()
        if self.neighbor is not None:
            oprot.writeFieldBegin('neighbor', TType.STRUCT, 6)
            self.neighbor.write(oprot)
            oprot.writeFieldEnd()
        if self.pod is not None:
            oprot.writeFieldBegin('pod', TType.I32, 7)
            oprot.writeI32(self.pod)
            oprot.writeFieldEnd()
        if self.node_capabilities is not None:
            oprot.writeFieldBegin('node_capabilities', TType.STRUCT, 10)
            self.node_capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.link_capabilities is not None:
            oprot.writeFieldBegin('link_capabilities', TType.STRUCT, 11)
            self.link_capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.holdtime is not None:
            oprot.writeFieldBegin('holdtime', TType.I16, 12)
            oprot.writeI16(self.holdtime)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.I32, 13)
            oprot.writeI32(self.label)
            oprot.writeFieldEnd()
        if self.not_a_ztp_offer is not None:
            oprot.writeFieldBegin('not_a_ztp_offer', TType.BOOL, 21)
            oprot.writeBool(self.not_a_ztp_offer)
            oprot.writeFieldEnd()
        if self.you_are_flood_repeater is not None:
            oprot.writeFieldBegin('you_are_flood_repeater', TType.BOOL, 22)
            oprot.writeBool(self.you_are_flood_repeater)
            oprot.writeFieldEnd()
        if self.you_are_sending_too_quickly is not None:
            oprot.writeFieldBegin('you_are_sending_too_quickly', TType.BOOL, 23)
            oprot.writeBool(self.you_are_sending_too_quickly)
            oprot.writeFieldEnd()
        if self.instance_name is not None:
            oprot.writeFieldBegin('instance_name', TType.STRING, 24)
            oprot.writeString(self.instance_name.encode('utf-8') if sys.version_info[0] == 2 else self.instance_name)
            oprot.writeFieldEnd()
        if self.fabric_id is not None:
            oprot.writeFieldBegin('fabric_id', TType.I16, 35)
            oprot.writeI16(self.fabric_id)
            oprot.writeFieldEnd()
        if self.auto_evpn_version is not None:
            oprot.writeFieldBegin('auto_evpn_version', TType.I16, 36)
            oprot.writeI16(self.auto_evpn_version)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_version is not None:
            oprot.writeFieldBegin('auto_flood_reflection_version', TType.I16, 40)
            oprot.writeI16(self.auto_flood_reflection_version)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_cluster_id is not None:
            oprot.writeFieldBegin('auto_flood_reflection_cluster_id', TType.I32, 41)
            oprot.writeI32(self.auto_flood_reflection_cluster_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.local_id is None:
            raise TProtocolException(message='Required field local_id is unset!')
        if self.flood_port is None:
            raise TProtocolException(message='Required field flood_port is unset!')
        if self.node_capabilities is None:
            raise TProtocolException(message='Required field node_capabilities is unset!')
        if self.holdtime is None:
            raise TProtocolException(message='Required field holdtime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LinkIDPair(object):
    """
    LinkID pair describes one of parallel links between two nodes.

    Attributes:
     - local_id: Node-wide unique value for the local link.
     - remote_id: Received remote link ID for this link.
     - platform_interface_index: Describes the local interface index of the link.
     - platform_interface_name: Describes the local interface name.
     - trusted_outer_security_key: Indicates whether the link is secured, i.e. protected by
    outer key, absence of this element means no indication,
    undefined outer key means not secured.
     - bfd_up: Indicates whether the link is protected by established
    BFD session.
     - address_families: Optional indication which address families are up on the
    interface
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'local_id', None, None, ),  # 1
        (2, TType.I32, 'remote_id', None, None, ),  # 2
        None,  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.I32, 'platform_interface_index', None, None, ),  # 10
        (11, TType.STRING, 'platform_interface_name', 'UTF8', None, ),  # 11
        (12, TType.BYTE, 'trusted_outer_security_key', None, None, ),  # 12
        (13, TType.BOOL, 'bfd_up', None, None, ),  # 13
        (14, TType.SET, 'address_families', (TType.I32, None, True), None, ),  # 14
    )

    def __init__(self, local_id=None, remote_id=None, platform_interface_index=None, platform_interface_name=None, trusted_outer_security_key=None, bfd_up=None, address_families=None,):
        super(LinkIDPair, self).__setattr__('local_id', local_id)
        super(LinkIDPair, self).__setattr__('remote_id', remote_id)
        super(LinkIDPair, self).__setattr__('platform_interface_index', platform_interface_index)
        super(LinkIDPair, self).__setattr__('platform_interface_name', platform_interface_name)
        super(LinkIDPair, self).__setattr__('trusted_outer_security_key', trusted_outer_security_key)
        super(LinkIDPair, self).__setattr__('bfd_up', bfd_up)
        super(LinkIDPair, self).__setattr__('address_families', address_families)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.local_id, self.remote_id, self.platform_interface_index, self.platform_interface_name, self.trusted_outer_security_key, self.bfd_up, self.address_families, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_local_id= None
        __var_remote_id= None
        __var_platform_interface_index= None
        __var_platform_interface_name= None
        __var_trusted_outer_security_key= None
        __var_bfd_up= None
        __var_address_families= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    __var_local_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    __var_remote_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    __var_platform_interface_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    __var_platform_interface_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BYTE:
                    __var_trusted_outer_security_key = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    __var_bfd_up = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.SET:
                    __var_address_families = set()
                    (_etype3, _size0) = iprot.readSetBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        __var_address_families.add(_elem5)
                    iprot.readSetEnd()
                    __var_address_families = frozenset(__var_address_families)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            local_id=__var_local_id,
            remote_id=__var_remote_id,
            platform_interface_index=__var_platform_interface_index,
            platform_interface_name=__var_platform_interface_name,
            trusted_outer_security_key=__var_trusted_outer_security_key,
            bfd_up=__var_bfd_up,
            address_families=__var_address_families,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LinkIDPair')
        if self.local_id is not None:
            oprot.writeFieldBegin('local_id', TType.I32, 1)
            oprot.writeI32(self.local_id)
            oprot.writeFieldEnd()
        if self.remote_id is not None:
            oprot.writeFieldBegin('remote_id', TType.I32, 2)
            oprot.writeI32(self.remote_id)
            oprot.writeFieldEnd()
        if self.platform_interface_index is not None:
            oprot.writeFieldBegin('platform_interface_index', TType.I32, 10)
            oprot.writeI32(self.platform_interface_index)
            oprot.writeFieldEnd()
        if self.platform_interface_name is not None:
            oprot.writeFieldBegin('platform_interface_name', TType.STRING, 11)
            oprot.writeString(self.platform_interface_name.encode('utf-8') if sys.version_info[0] == 2 else self.platform_interface_name)
            oprot.writeFieldEnd()
        if self.trusted_outer_security_key is not None:
            oprot.writeFieldBegin('trusted_outer_security_key', TType.BYTE, 12)
            oprot.writeByte(self.trusted_outer_security_key)
            oprot.writeFieldEnd()
        if self.bfd_up is not None:
            oprot.writeFieldBegin('bfd_up', TType.BOOL, 13)
            oprot.writeBool(self.bfd_up)
            oprot.writeFieldEnd()
        if self.address_families is not None:
            oprot.writeFieldBegin('address_families', TType.SET, 14)
            oprot.writeSetBegin(TType.I32, len(self.address_families))
            for iter6 in self.address_families:
                oprot.writeI32(iter6)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.local_id is None:
            raise TProtocolException(message='Required field local_id is unset!')
        if self.remote_id is None:
            raise TProtocolException(message='Required field remote_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEID(object):
    """
    Unique ID of a TIE.

    Attributes:
     - direction: direction of TIE
     - originator: indicates originator of the TIE
     - tietype: type of the tie
     - tie_nr: number of the tie
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'direction', None, None, ),  # 1
        (2, TType.I64, 'originator', None, None, ),  # 2
        (3, TType.I32, 'tietype', None, None, ),  # 3
        (4, TType.I32, 'tie_nr', None, None, ),  # 4
    )

    def __init__(self, direction=None, originator=None, tietype=None, tie_nr=None,):
        super(TIEID, self).__setattr__('direction', direction)
        super(TIEID, self).__setattr__('originator', originator)
        super(TIEID, self).__setattr__('tietype', tietype)
        super(TIEID, self).__setattr__('tie_nr', tie_nr)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.direction, self.originator, self.tietype, self.tie_nr, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_direction= None
        __var_originator= None
        __var_tietype= None
        __var_tie_nr= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    __var_direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    __var_originator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    __var_tietype = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    __var_tie_nr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            direction=__var_direction,
            originator=__var_originator,
            tietype=__var_tietype,
            tie_nr=__var_tie_nr,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEID')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 1)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.originator is not None:
            oprot.writeFieldBegin('originator', TType.I64, 2)
            oprot.writeI64(self.originator)
            oprot.writeFieldEnd()
        if self.tietype is not None:
            oprot.writeFieldBegin('tietype', TType.I32, 3)
            oprot.writeI32(self.tietype)
            oprot.writeFieldEnd()
        if self.tie_nr is not None:
            oprot.writeFieldBegin('tie_nr', TType.I32, 4)
            oprot.writeI32(self.tie_nr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.direction is None:
            raise TProtocolException(message='Required field direction is unset!')
        if self.originator is None:
            raise TProtocolException(message='Required field originator is unset!')
        if self.tietype is None:
            raise TProtocolException(message='Required field tietype is unset!')
        if self.tie_nr is None:
            raise TProtocolException(message='Required field tie_nr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEHeader(object):
    """
    Header of a TIE.

    Attributes:
     - tieid: ID of the tie.
     - seq_nr: Sequence number of the tie.
     - origination_time: Absolute timestamp when the TIE was generated.
     - origination_lifetime: Original lifetime when the TIE was generated.
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'tieid', (TIEID, TIEID.thrift_spec), None, ),  # 2
        (3, TType.I64, 'seq_nr', None, None, ),  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.STRUCT, 'origination_time', (common.ttypes.IEEE802_1ASTimeStampType, common.ttypes.IEEE802_1ASTimeStampType.thrift_spec), None, ),  # 10
        None,  # 11
        (12, TType.I32, 'origination_lifetime', None, None, ),  # 12
    )

    def __init__(self, tieid=None, seq_nr=None, origination_time=None, origination_lifetime=None,):
        self.tieid = tieid
        self.seq_nr = seq_nr
        self.origination_time = origination_time
        self.origination_lifetime = origination_lifetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.tieid = None
        self.seq_nr = None
        self.origination_time = None
        self.origination_lifetime = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.tieid = TIEID.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.seq_nr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.origination_time = common.ttypes.IEEE802_1ASTimeStampType()
                    self.origination_time.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.origination_lifetime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEHeader')
        if self.tieid is not None:
            oprot.writeFieldBegin('tieid', TType.STRUCT, 2)
            self.tieid.write(oprot)
            oprot.writeFieldEnd()
        if self.seq_nr is not None:
            oprot.writeFieldBegin('seq_nr', TType.I64, 3)
            oprot.writeI64(self.seq_nr)
            oprot.writeFieldEnd()
        if self.origination_time is not None:
            oprot.writeFieldBegin('origination_time', TType.STRUCT, 10)
            self.origination_time.write(oprot)
            oprot.writeFieldEnd()
        if self.origination_lifetime is not None:
            oprot.writeFieldBegin('origination_lifetime', TType.I32, 12)
            oprot.writeI32(self.origination_lifetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tieid is None:
            raise TProtocolException(message='Required field tieid is unset!')
        if self.seq_nr is None:
            raise TProtocolException(message='Required field seq_nr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEHeaderWithLifeTime(object):
    """
    Header of a TIE as described in TIRE/TIDE.

    Attributes:
     - header
     - remaining_lifetime: Remaining lifetime.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (TIEHeader, TIEHeader.thrift_spec), None, ),  # 1
        (2, TType.I32, 'remaining_lifetime', None, None, ),  # 2
    )

    def __init__(self, header=None, remaining_lifetime=None,):
        self.header = header
        self.remaining_lifetime = remaining_lifetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.header = None
        self.remaining_lifetime = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = TIEHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.remaining_lifetime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEHeaderWithLifeTime')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.remaining_lifetime is not None:
            oprot.writeFieldBegin('remaining_lifetime', TType.I32, 2)
            oprot.writeI32(self.remaining_lifetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.remaining_lifetime is None:
            raise TProtocolException(message='Required field remaining_lifetime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIDEPacket(object):
    """
    TIDE with *sorted* TIE headers.

    Attributes:
     - start_range: First TIE header in the tide packet.
     - end_range: Last TIE header in the tide packet.
     - headers: _Sorted_ list of headers.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'start_range', (TIEID, TIEID.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'end_range', (TIEID, TIEID.thrift_spec), None, ),  # 2
        (3, TType.LIST, 'headers', (TType.STRUCT, (TIEHeaderWithLifeTime, TIEHeaderWithLifeTime.thrift_spec), True), None, ),  # 3
    )

    def __init__(self, start_range=None, end_range=None, headers=None,):
        self.start_range = start_range
        self.end_range = end_range
        self.headers = headers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.start_range = None
        self.end_range = None
        self.headers = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.start_range = TIEID.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.end_range = TIEID.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.headers = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TIEHeaderWithLifeTime()
                        _elem12.read(iprot)
                        self.headers.append(_elem12)
                    self.headers = tuple(self.headers)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIDEPacket')
        if self.start_range is not None:
            oprot.writeFieldBegin('start_range', TType.STRUCT, 1)
            self.start_range.write(oprot)
            oprot.writeFieldEnd()
        if self.end_range is not None:
            oprot.writeFieldBegin('end_range', TType.STRUCT, 2)
            self.end_range.write(oprot)
            oprot.writeFieldEnd()
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.headers))
            for iter13 in self.headers:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.start_range is None:
            raise TProtocolException(message='Required field start_range is unset!')
        if self.end_range is None:
            raise TProtocolException(message='Required field end_range is unset!')
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIREPacket(object):
    """
    TIRE packet

    Attributes:
     - headers
    """

    thrift_spec = (
        None,  # 0
        (1, TType.SET, 'headers', (TType.STRUCT, (TIEHeaderWithLifeTime, TIEHeaderWithLifeTime.thrift_spec), True), None, ),  # 1
    )

    def __init__(self, headers=None,):
        self.headers = headers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.headers = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.headers = set()
                    (_etype17, _size14) = iprot.readSetBegin()
                    for _i18 in range(_size14):
                        _elem19 = TIEHeaderWithLifeTime()
                        _elem19.read(iprot)
                        self.headers.add(_elem19)
                    iprot.readSetEnd()
                    self.headers = frozenset(self.headers)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIREPacket')
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.SET, 1)
            oprot.writeSetBegin(TType.STRUCT, len(self.headers))
            for iter20 in self.headers:
                iter20.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeNeighborsTIEElement(object):
    """
    neighbor of a node

    Attributes:
     - level: level of neighbor
     - cost: Cost to neighbor. Ignore anything larger than `infinite_distance` and `invalid_distance`
     - link_ids: can carry description of multiple parallel links in a TIE
     - bandwidth: total bandwith to neighbor as sum of all parallel links
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'level', None, None, ),  # 1
        None,  # 2
        (3, TType.I32, 'cost', None, 1, ),  # 3
        (4, TType.SET, 'link_ids', (TType.STRUCT, (LinkIDPair, LinkIDPair.thrift_spec), True), None, ),  # 4
        (5, TType.I32, 'bandwidth', None, 100, ),  # 5
    )

    def __init__(self, level=None, cost=thrift_spec[3][4], link_ids=None, bandwidth=thrift_spec[5][4],):
        super(NodeNeighborsTIEElement, self).__setattr__('level', level)
        if cost is self.thrift_spec[3][4]:
            cost = 1
        super(NodeNeighborsTIEElement, self).__setattr__('cost', cost)
        super(NodeNeighborsTIEElement, self).__setattr__('link_ids', link_ids)
        if bandwidth is self.thrift_spec[5][4]:
            bandwidth = 100
        super(NodeNeighborsTIEElement, self).__setattr__('bandwidth', bandwidth)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.level, self.cost, self.link_ids, self.bandwidth, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_level= None
        __var_cost= None
        __var_link_ids= None
        __var_bandwidth= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    __var_level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    __var_cost = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    __var_link_ids = set()
                    (_etype24, _size21) = iprot.readSetBegin()
                    for _i25 in range(_size21):
                        _elem26 = LinkIDPair.read(iprot)
                        __var_link_ids.add(_elem26)
                    iprot.readSetEnd()
                    __var_link_ids = frozenset(__var_link_ids)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    __var_bandwidth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            level=__var_level,
            cost=__var_cost,
            link_ids=__var_link_ids,
            bandwidth=__var_bandwidth,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeNeighborsTIEElement')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 1)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        if self.cost is not None:
            oprot.writeFieldBegin('cost', TType.I32, 3)
            oprot.writeI32(self.cost)
            oprot.writeFieldEnd()
        if self.link_ids is not None:
            oprot.writeFieldBegin('link_ids', TType.SET, 4)
            oprot.writeSetBegin(TType.STRUCT, len(self.link_ids))
            for iter27 in self.link_ids:
                iter27.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.bandwidth is not None:
            oprot.writeFieldBegin('bandwidth', TType.I32, 5)
            oprot.writeI32(self.bandwidth)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeFlags(object):
    """
    Indication flags of the node.

    Attributes:
     - overload: Indicates that node is in overload, do not transit traffic
    through it.
     - acting_auto_evpn_dci_when_tof: acting as DCI for auto-evpn, necessary for proper RR election where DCIs are preferred
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'overload', None, False, ),  # 1
        None,  # 2
        None,  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.BOOL, 'acting_auto_evpn_dci_when_tof', None, False, ),  # 10
    )

    def __init__(self, overload=thrift_spec[1][4], acting_auto_evpn_dci_when_tof=thrift_spec[10][4],):
        super(NodeFlags, self).__setattr__('overload', overload)
        super(NodeFlags, self).__setattr__('acting_auto_evpn_dci_when_tof', acting_auto_evpn_dci_when_tof)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.overload, self.acting_auto_evpn_dci_when_tof, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_overload= None
        __var_acting_auto_evpn_dci_when_tof= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    __var_overload = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    __var_acting_auto_evpn_dci_when_tof = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            overload=__var_overload,
            acting_auto_evpn_dci_when_tof=__var_acting_auto_evpn_dci_when_tof,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeFlags')
        if self.overload is not None:
            oprot.writeFieldBegin('overload', TType.BOOL, 1)
            oprot.writeBool(self.overload)
            oprot.writeFieldEnd()
        if self.acting_auto_evpn_dci_when_tof is not None:
            oprot.writeFieldBegin('acting_auto_evpn_dci_when_tof', TType.BOOL, 10)
            oprot.writeBool(self.acting_auto_evpn_dci_when_tof)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeTIEElement(object):
    """
    Description of a node.

    Attributes:
     - level: Level of the node.
     - neighbors: Node's neighbors. Multiple node TIEs can carry disjoint sets of neighbors.
     - capabilities: Capabilities of the node.
     - flags: Flags of the node.
     - name: Optional node name for easier operations.
     - pod: PoD to which the node belongs.
     - startup_time: optional startup time of the node
     - miscabled_links: If any local links are miscabled, this indication is flooded.
     - same_plane_tofs: ToFs in the same plane. Only carried by ToF. Multiple Node TIEs can carry disjoint sets of ToFs
    which MUST be joined to form a single set.
     - auto_evpn_version: It provides optional version of EVPN ZTP as 256 * MAJOR + MINOR, if set auto EVPN is enabled.
     - fabric_id: It provides the optional ID of the Fabric configured
     - auto_evpn_model: provides optionally the EVPN model supported
     - auto_flood_reflection_version: It provides optional version of FR ZTP as 256 * MAJOR + MINOR, if set indicates auto FR is enabled.
     - auto_flood_reflection_cluster_id: cluster ID of Auto FR
     - auto_flood_reflection_preference: preference to become FR, if not set it indicates that the node cannot perform flood reflection role
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'level', None, None, ),  # 1
        (2, TType.MAP, 'neighbors', (TType.I64, None, TType.STRUCT, (NodeNeighborsTIEElement, NodeNeighborsTIEElement.thrift_spec), False), None, ),  # 2
        (3, TType.STRUCT, 'capabilities', (NodeCapabilities, NodeCapabilities.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'flags', (NodeFlags, NodeFlags.thrift_spec), None, ),  # 4
        (5, TType.STRING, 'name', 'UTF8', None, ),  # 5
        (6, TType.I32, 'pod', None, None, ),  # 6
        (7, TType.I64, 'startup_time', None, None, ),  # 7
        None,  # 8
        None,  # 9
        (10, TType.SET, 'miscabled_links', (TType.I32, None, True), None, ),  # 10
        None,  # 11
        (12, TType.SET, 'same_plane_tofs', (TType.I64, None, True), None, ),  # 12
        None,  # 13
        None,  # 14
        None,  # 15
        None,  # 16
        None,  # 17
        None,  # 18
        None,  # 19
        None,  # 20
        (21, TType.I16, 'auto_evpn_version', None, None, ),  # 21
        (22, TType.I16, 'fabric_id', None, 1, ),  # 22
        None,  # 23
        None,  # 24
        (25, TType.I32, 'auto_evpn_model', None, 0, ),  # 25
        None,  # 26
        None,  # 27
        None,  # 28
        None,  # 29
        (30, TType.I16, 'auto_flood_reflection_version', None, None, ),  # 30
        (31, TType.I32, 'auto_flood_reflection_cluster_id', None, None, ),  # 31
        (32, TType.I32, 'auto_flood_reflection_preference', None, None, ),  # 32
    )

    def __init__(self, level=None, neighbors=None, capabilities=None, flags=None, name=None, pod=None, startup_time=None, miscabled_links=None, same_plane_tofs=None, auto_evpn_version=None, fabric_id=thrift_spec[22][4], auto_evpn_model=thrift_spec[25][4], auto_flood_reflection_version=None, auto_flood_reflection_cluster_id=None, auto_flood_reflection_preference=None,):
        super(NodeTIEElement, self).__setattr__('level', level)
        super(NodeTIEElement, self).__setattr__('neighbors', neighbors)
        super(NodeTIEElement, self).__setattr__('capabilities', capabilities)
        super(NodeTIEElement, self).__setattr__('flags', flags)
        super(NodeTIEElement, self).__setattr__('name', name)
        super(NodeTIEElement, self).__setattr__('pod', pod)
        super(NodeTIEElement, self).__setattr__('startup_time', startup_time)
        super(NodeTIEElement, self).__setattr__('miscabled_links', miscabled_links)
        super(NodeTIEElement, self).__setattr__('same_plane_tofs', same_plane_tofs)
        super(NodeTIEElement, self).__setattr__('auto_evpn_version', auto_evpn_version)
        if fabric_id is self.thrift_spec[22][4]:
            fabric_id = 1
        super(NodeTIEElement, self).__setattr__('fabric_id', fabric_id)
        super(NodeTIEElement, self).__setattr__('auto_evpn_model', auto_evpn_model)
        super(NodeTIEElement, self).__setattr__('auto_flood_reflection_version', auto_flood_reflection_version)
        super(NodeTIEElement, self).__setattr__('auto_flood_reflection_cluster_id', auto_flood_reflection_cluster_id)
        super(NodeTIEElement, self).__setattr__('auto_flood_reflection_preference', auto_flood_reflection_preference)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.level, self.neighbors, self.capabilities, self.flags, self.name, self.pod, self.startup_time, self.miscabled_links, self.same_plane_tofs, self.auto_evpn_version, self.fabric_id, self.auto_evpn_model, self.auto_flood_reflection_version, self.auto_flood_reflection_cluster_id, self.auto_flood_reflection_preference, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_level= None
        __var_neighbors= None
        __var_capabilities= None
        __var_flags= None
        __var_name= None
        __var_pod= None
        __var_startup_time= None
        __var_miscabled_links= None
        __var_same_plane_tofs= None
        __var_auto_evpn_version= None
        __var_fabric_id= None
        __var_auto_evpn_model= None
        __var_auto_flood_reflection_version= None
        __var_auto_flood_reflection_cluster_id= None
        __var_auto_flood_reflection_preference= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    __var_level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    __var_neighbors = {}
                    (_ktype29, _vtype30, _size28) = iprot.readMapBegin()
                    for _i32 in range(_size28):
                        _key33 = iprot.readI64()
                        _val34 = NodeNeighborsTIEElement.read(iprot)
                        __var_neighbors[_key33] = _val34
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    __var_capabilities = NodeCapabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    __var_flags = NodeFlags.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    __var_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    __var_pod = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    __var_startup_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.SET:
                    __var_miscabled_links = set()
                    (_etype38, _size35) = iprot.readSetBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        __var_miscabled_links.add(_elem40)
                    iprot.readSetEnd()
                    __var_miscabled_links = frozenset(__var_miscabled_links)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.SET:
                    __var_same_plane_tofs = set()
                    (_etype44, _size41) = iprot.readSetBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readI64()
                        __var_same_plane_tofs.add(_elem46)
                    iprot.readSetEnd()
                    __var_same_plane_tofs = frozenset(__var_same_plane_tofs)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I16:
                    __var_auto_evpn_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I16:
                    __var_fabric_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I32:
                    __var_auto_evpn_model = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I16:
                    __var_auto_flood_reflection_version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    __var_auto_flood_reflection_cluster_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I32:
                    __var_auto_flood_reflection_preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            level=__var_level,
            neighbors=__var_neighbors,
            capabilities=__var_capabilities,
            flags=__var_flags,
            name=__var_name,
            pod=__var_pod,
            startup_time=__var_startup_time,
            miscabled_links=__var_miscabled_links,
            same_plane_tofs=__var_same_plane_tofs,
            auto_evpn_version=__var_auto_evpn_version,
            fabric_id=__var_fabric_id,
            auto_evpn_model=__var_auto_evpn_model,
            auto_flood_reflection_version=__var_auto_flood_reflection_version,
            auto_flood_reflection_cluster_id=__var_auto_flood_reflection_cluster_id,
            auto_flood_reflection_preference=__var_auto_flood_reflection_preference,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeTIEElement')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 1)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        if self.neighbors is not None:
            oprot.writeFieldBegin('neighbors', TType.MAP, 2)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.neighbors))
            for kiter47, viter48 in self.neighbors.items():
                oprot.writeI64(kiter47)
                viter48.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.capabilities is not None:
            oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
            self.capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 4)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 5)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.pod is not None:
            oprot.writeFieldBegin('pod', TType.I32, 6)
            oprot.writeI32(self.pod)
            oprot.writeFieldEnd()
        if self.startup_time is not None:
            oprot.writeFieldBegin('startup_time', TType.I64, 7)
            oprot.writeI64(self.startup_time)
            oprot.writeFieldEnd()
        if self.miscabled_links is not None:
            oprot.writeFieldBegin('miscabled_links', TType.SET, 10)
            oprot.writeSetBegin(TType.I32, len(self.miscabled_links))
            for iter49 in self.miscabled_links:
                oprot.writeI32(iter49)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.same_plane_tofs is not None:
            oprot.writeFieldBegin('same_plane_tofs', TType.SET, 12)
            oprot.writeSetBegin(TType.I64, len(self.same_plane_tofs))
            for iter50 in self.same_plane_tofs:
                oprot.writeI64(iter50)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.auto_evpn_version is not None:
            oprot.writeFieldBegin('auto_evpn_version', TType.I16, 21)
            oprot.writeI16(self.auto_evpn_version)
            oprot.writeFieldEnd()
        if self.fabric_id is not None:
            oprot.writeFieldBegin('fabric_id', TType.I16, 22)
            oprot.writeI16(self.fabric_id)
            oprot.writeFieldEnd()
        if self.auto_evpn_model is not None:
            oprot.writeFieldBegin('auto_evpn_model', TType.I32, 25)
            oprot.writeI32(self.auto_evpn_model)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_version is not None:
            oprot.writeFieldBegin('auto_flood_reflection_version', TType.I16, 30)
            oprot.writeI16(self.auto_flood_reflection_version)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_cluster_id is not None:
            oprot.writeFieldBegin('auto_flood_reflection_cluster_id', TType.I32, 31)
            oprot.writeI32(self.auto_flood_reflection_cluster_id)
            oprot.writeFieldEnd()
        if self.auto_flood_reflection_preference is not None:
            oprot.writeFieldBegin('auto_flood_reflection_preference', TType.I32, 32)
            oprot.writeI32(self.auto_flood_reflection_preference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        if self.neighbors is None:
            raise TProtocolException(message='Required field neighbors is unset!')
        if self.capabilities is None:
            raise TProtocolException(message='Required field capabilities is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrefixAttributes(object):
    """
    Attributes of a prefix.

    Attributes:
     - metric: Distance of the prefix.
     - tags: Generic unordered set of route tags, can be redistributed
    to other protocols or use within the context of real time
    analytics.
     - monotonic_clock: Monotonic clock for mobile addresses.
     - loopback: Indicates if the prefix is a node loopback.
     - directly_attached: Indicates that the prefix is directly attached.
     - from_link: link to which the address belongs to.
     - label: Optional, per prefix significant label.
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I32, 'metric', None, 1, ),  # 2
        (3, TType.SET, 'tags', (TType.I64, None, True), None, ),  # 3
        (4, TType.STRUCT, 'monotonic_clock', (common.ttypes.PrefixSequenceType, common.ttypes.PrefixSequenceType.thrift_spec), None, ),  # 4
        None,  # 5
        (6, TType.BOOL, 'loopback', None, False, ),  # 6
        (7, TType.BOOL, 'directly_attached', None, True, ),  # 7
        None,  # 8
        None,  # 9
        (10, TType.I32, 'from_link', None, None, ),  # 10
        None,  # 11
        (12, TType.I32, 'label', None, None, ),  # 12
    )

    def __init__(self, metric=thrift_spec[2][4], tags=None, monotonic_clock=None, loopback=thrift_spec[6][4], directly_attached=thrift_spec[7][4], from_link=None, label=None,):
        if metric is self.thrift_spec[2][4]:
            metric = 1
        super(PrefixAttributes, self).__setattr__('metric', metric)
        super(PrefixAttributes, self).__setattr__('tags', tags)
        super(PrefixAttributes, self).__setattr__('monotonic_clock', monotonic_clock)
        super(PrefixAttributes, self).__setattr__('loopback', loopback)
        super(PrefixAttributes, self).__setattr__('directly_attached', directly_attached)
        super(PrefixAttributes, self).__setattr__('from_link', from_link)
        super(PrefixAttributes, self).__setattr__('label', label)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.metric, self.tags, self.monotonic_clock, self.loopback, self.directly_attached, self.from_link, self.label, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_metric= None
        __var_tags= None
        __var_monotonic_clock= None
        __var_loopback= None
        __var_directly_attached= None
        __var_from_link= None
        __var_label= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    __var_metric = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    __var_tags = set()
                    (_etype54, _size51) = iprot.readSetBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readI64()
                        __var_tags.add(_elem56)
                    iprot.readSetEnd()
                    __var_tags = frozenset(__var_tags)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    __var_monotonic_clock = common.ttypes.PrefixSequenceType()
                    __var_monotonic_clock.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    __var_loopback = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    __var_directly_attached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    __var_from_link = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    __var_label = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            metric=__var_metric,
            tags=__var_tags,
            monotonic_clock=__var_monotonic_clock,
            loopback=__var_loopback,
            directly_attached=__var_directly_attached,
            from_link=__var_from_link,
            label=__var_label,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PrefixAttributes')
        if self.metric is not None:
            oprot.writeFieldBegin('metric', TType.I32, 2)
            oprot.writeI32(self.metric)
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.SET, 3)
            oprot.writeSetBegin(TType.I64, len(self.tags))
            for iter57 in self.tags:
                oprot.writeI64(iter57)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.monotonic_clock is not None:
            oprot.writeFieldBegin('monotonic_clock', TType.STRUCT, 4)
            self.monotonic_clock.write(oprot)
            oprot.writeFieldEnd()
        if self.loopback is not None:
            oprot.writeFieldBegin('loopback', TType.BOOL, 6)
            oprot.writeBool(self.loopback)
            oprot.writeFieldEnd()
        if self.directly_attached is not None:
            oprot.writeFieldBegin('directly_attached', TType.BOOL, 7)
            oprot.writeBool(self.directly_attached)
            oprot.writeFieldEnd()
        if self.from_link is not None:
            oprot.writeFieldBegin('from_link', TType.I32, 10)
            oprot.writeI32(self.from_link)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.I32, 12)
            oprot.writeI32(self.label)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metric is None:
            raise TProtocolException(message='Required field metric is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrefixTIEElement(object):
    """
    TIE carrying prefixes

    Attributes:
     - prefixes: Prefixes with the associated attributes.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'prefixes', (TType.STRUCT, (common.ttypes.IPPrefixType, common.ttypes.IPPrefixType.thrift_spec), TType.STRUCT, (PrefixAttributes, PrefixAttributes.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, prefixes=None,):
        super(PrefixTIEElement, self).__setattr__('prefixes', prefixes)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.prefixes, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_prefixes= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    __var_prefixes = {}
                    (_ktype59, _vtype60, _size58) = iprot.readMapBegin()
                    for _i62 in range(_size58):
                        _key63 = common.ttypes.IPPrefixType.read(iprot)
                        _val64 = PrefixAttributes.read(iprot)
                        __var_prefixes[_key63] = _val64
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            prefixes=__var_prefixes,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PrefixTIEElement')
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.prefixes))
            for kiter65, viter66 in self.prefixes.items():
                kiter65.write(oprot)
                viter66.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixes is None:
            raise TProtocolException(message='Required field prefixes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KeyValueTIEElementContent(object):
    """
    Defines the targeted nodes and the value carried.

    Attributes:
     - targets
     - value
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'targets', None, 0, ),  # 1
        (2, TType.STRING, 'value', 'BINARY', None, ),  # 2
    )

    def __init__(self, targets=thrift_spec[1][4], value=None,):
        if targets is self.thrift_spec[1][4]:
            targets = 0
        self.targets = targets
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.targets = None
        self.value = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.targets = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('KeyValueTIEElementContent')
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.I64, 1)
            oprot.writeI64(self.targets)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KeyValueTIEElement(object):
    """
    Generic key value pairs.

    Attributes:
     - keyvalues
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyvalues', (TType.I32, None, TType.STRUCT, (KeyValueTIEElementContent, KeyValueTIEElementContent.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, keyvalues=None,):
        super(KeyValueTIEElement, self).__setattr__('keyvalues', keyvalues)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.keyvalues, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_keyvalues= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    __var_keyvalues = {}
                    (_ktype68, _vtype69, _size67) = iprot.readMapBegin()
                    for _i71 in range(_size67):
                        _key72 = iprot.readI32()
                        _val73 = KeyValueTIEElementContent()
                        _val73.read(iprot)
                        __var_keyvalues[_key72] = _val73
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            keyvalues=__var_keyvalues,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('KeyValueTIEElement')
        if self.keyvalues is not None:
            oprot.writeFieldBegin('keyvalues', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.keyvalues))
            for kiter74, viter75 in self.keyvalues.items():
                oprot.writeI32(kiter74)
                viter75.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keyvalues is None:
            raise TProtocolException(message='Required field keyvalues is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEElement(object):
    """
    Single element in a TIE.

    Attributes:
     - node: Used in case of enum common.TIETypeType.NodeTIEType.
     - prefixes: Used in case of enum common.TIETypeType.PrefixTIEType.
     - positive_disaggregation_prefixes: Positive prefixes (always southbound).
     - negative_disaggregation_prefixes: Transitive, negative prefixes (always southbound)
     - external_prefixes: Externally reimported prefixes.
     - positive_external_disaggregation_prefixes: Positive external disaggregated prefixes (always southbound).
     - keyvalues: Key-Value store elements.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'node', (NodeTIEElement, NodeTIEElement.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'positive_disaggregation_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 3
        None,  # 4
        (5, TType.STRUCT, 'negative_disaggregation_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 5
        (6, TType.STRUCT, 'external_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 6
        (7, TType.STRUCT, 'positive_external_disaggregation_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 7
        None,  # 8
        (9, TType.STRUCT, 'keyvalues', (KeyValueTIEElement, KeyValueTIEElement.thrift_spec), None, ),  # 9
    )

    def __init__(self, node=None, prefixes=None, positive_disaggregation_prefixes=None, negative_disaggregation_prefixes=None, external_prefixes=None, positive_external_disaggregation_prefixes=None, keyvalues=None,):
        super(TIEElement, self).__setattr__('node', node)
        super(TIEElement, self).__setattr__('prefixes', prefixes)
        super(TIEElement, self).__setattr__('positive_disaggregation_prefixes', positive_disaggregation_prefixes)
        super(TIEElement, self).__setattr__('negative_disaggregation_prefixes', negative_disaggregation_prefixes)
        super(TIEElement, self).__setattr__('external_prefixes', external_prefixes)
        super(TIEElement, self).__setattr__('positive_external_disaggregation_prefixes', positive_external_disaggregation_prefixes)
        super(TIEElement, self).__setattr__('keyvalues', keyvalues)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.node, self.prefixes, self.positive_disaggregation_prefixes, self.negative_disaggregation_prefixes, self.external_prefixes, self.positive_external_disaggregation_prefixes, self.keyvalues, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, (cls, cls.thrift_spec))
        __var_node= None
        __var_prefixes= None
        __var_positive_disaggregation_prefixes= None
        __var_negative_disaggregation_prefixes= None
        __var_external_prefixes= None
        __var_positive_external_disaggregation_prefixes= None
        __var_keyvalues= None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    __var_node = NodeTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    __var_prefixes = PrefixTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    __var_positive_disaggregation_prefixes = PrefixTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    __var_negative_disaggregation_prefixes = PrefixTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    __var_external_prefixes = PrefixTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    __var_positive_external_disaggregation_prefixes = PrefixTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    __var_keyvalues = KeyValueTIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            node=__var_node,
            prefixes=__var_prefixes,
            positive_disaggregation_prefixes=__var_positive_disaggregation_prefixes,
            negative_disaggregation_prefixes=__var_negative_disaggregation_prefixes,
            external_prefixes=__var_external_prefixes,
            positive_external_disaggregation_prefixes=__var_positive_external_disaggregation_prefixes,
            keyvalues=__var_keyvalues,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEElement')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.STRUCT, 2)
            self.prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.positive_disaggregation_prefixes is not None:
            oprot.writeFieldBegin('positive_disaggregation_prefixes', TType.STRUCT, 3)
            self.positive_disaggregation_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.negative_disaggregation_prefixes is not None:
            oprot.writeFieldBegin('negative_disaggregation_prefixes', TType.STRUCT, 5)
            self.negative_disaggregation_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.external_prefixes is not None:
            oprot.writeFieldBegin('external_prefixes', TType.STRUCT, 6)
            self.external_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.positive_external_disaggregation_prefixes is not None:
            oprot.writeFieldBegin('positive_external_disaggregation_prefixes', TType.STRUCT, 7)
            self.positive_external_disaggregation_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.keyvalues is not None:
            oprot.writeFieldBegin('keyvalues', TType.STRUCT, 9)
            self.keyvalues.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEPacket(object):
    """
    TIE packet

    Attributes:
     - header
     - element
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (TIEHeader, TIEHeader.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'element', (TIEElement, TIEElement.thrift_spec), None, ),  # 2
    )

    def __init__(self, header=None, element=None,):
        self.header = header
        self.element = element

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.header = None
        self.element = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = TIEHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.element = TIEElement.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEPacket')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.element is not None:
            oprot.writeFieldBegin('element', TType.STRUCT, 2)
            self.element.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.element is None:
            raise TProtocolException(message='Required field element is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PacketContent(object):
    """
    Content of a RIFT packet.

    Attributes:
     - lie
     - tide
     - tire
     - tie
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'lie', (LIEPacket, LIEPacket.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'tide', (TIDEPacket, TIDEPacket.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'tire', (TIREPacket, TIREPacket.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'tie', (TIEPacket, TIEPacket.thrift_spec), None, ),  # 4
    )

    def __init__(self, lie=None, tide=None, tire=None, tie=None,):
        self.lie = lie
        self.tide = tide
        self.tire = tire
        self.tie = tie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.lie = None
        self.tide = None
        self.tire = None
        self.tie = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lie = LIEPacket()
                    self.lie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tide = TIDEPacket()
                    self.tide.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tire = TIREPacket()
                    self.tire.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tie = TIEPacket()
                    self.tie.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PacketContent')
        if self.lie is not None:
            oprot.writeFieldBegin('lie', TType.STRUCT, 1)
            self.lie.write(oprot)
            oprot.writeFieldEnd()
        if self.tide is not None:
            oprot.writeFieldBegin('tide', TType.STRUCT, 2)
            self.tide.write(oprot)
            oprot.writeFieldEnd()
        if self.tire is not None:
            oprot.writeFieldBegin('tire', TType.STRUCT, 3)
            self.tire.write(oprot)
            oprot.writeFieldEnd()
        if self.tie is not None:
            oprot.writeFieldBegin('tie', TType.STRUCT, 4)
            self.tie.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProtocolPacket(object):
    """
    RIFT packet structure.

    Attributes:
     - header
     - content
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (PacketHeader, PacketHeader.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'content', (PacketContent, PacketContent.thrift_spec), None, ),  # 2
    )

    def __init__(self, header=None, content=None,):
        self.header = header
        self.content = content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        self.header = None
        self.content = None
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = PacketHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.content = PacketContent()
                    self.content.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ProtocolPacket')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRUCT, 2)
            self.content.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.content is None:
            raise TProtocolException(message='Required field content is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
